=== tests/cases/conformance/classes/members/privateNames/privateNamesInNestedClasses.ts ===
   #foo = "A's #foo";
>"A's #foo" : "A's #foo"

   #bar = "A's #bar";
>"A's #bar" : "A's #bar"

   method () {
>method () : any
>method : any

       class B {
>B : B

           #foo = "B's #foo";
>#foo : string
>"B's #foo" : "B's #foo"

           bar (a) {
>bar : (a: any) => void
>a : any

               a.#foo; // OK, no compile-time error, don't know what `a` is
>a.#foo : any
>a : any
           }
           baz (a: A) {
>baz : (a: any) => void
>a : any

               a.#foo; // compile-time error, shadowed
>a.#foo : any
>a : any
           }
           quux (b: B) {
>quux : (b: B) => void
>b : B

               b.#foo; // OK
>b.#foo : string
>b : B
           }
       }
       const a = new A();
>a : any
>new A() : any
>A : any

       new B().bar(a);
>new B().bar(a) : void
>new B().bar : (a: any) => void
>new B() : B
>B : typeof B
>bar : (a: any) => void
>a : any

       new B().baz(a);
>new B().baz(a) : void
>new B().baz : (a: any) => void
>new B() : B
>B : typeof B
>baz : (a: any) => void
>a : any

       const b = new B();
>b : B
>new B() : B
>B : typeof B

       new B().quux(b);
>new B().quux(b) : void
>new B().quux : (b: B) => void
>new B() : B
>B : typeof B
>quux : (b: B) => void
>b : B
   }
}

new A().method();
>new A().method() : any
>new A().method : any
>new A() : any
>A : any
>method : any

